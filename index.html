<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="initial-scale=1,width=device-width" />
  <title>Mappa</title>

  <!-- Leaflet da CDN (niente dipendenze locali) -->
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
    crossorigin=""
  />
  <style>
    html, body, #map { height: 100%; margin: 0; padding: 0; }
  </style>
</head>
<body>
  <div id="map"></div>

  <script
    src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
    integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
    crossorigin=""
  ></script>

  <!-- (facoltativo) i tuoi punti. Se questo file manca o ha un nome variabile diverso, il try/catch sotto evita blocchi -->
  <script src="data/Insediamenti_1.js"></script>

  <script>
    // 1) Mappa: limitiamo lo zoom al massimo livello reale generato
    const MAX_NATIVE = 16; // <-- METTI il tuo massimo: 15 o 16 o 17
    const map = L.map('map', { minZoom: 0, maxZoom: MAX_NATIVE }).setView([45.8, 9.08], 10);

    // 2) Fallback OSM: così vedi sempre qualcosa anche se i tiles personalizzati falliscono
    const osm = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      maxZoom: 19,
      attribution: '&copy; OpenStreetMap'
    }).addTo(map);

    // 3) I TUOI TILES (XYZ 256px, z=0..MAX_NATIVE). Cambia il percorso se la cartella non è accanto all’index.
    const tiles = L.tileLayer('./tiles_raster/{z}/{x}/{y}.png?v=3', {
      minZoom: 0,
      maxZoom: MAX_NATIVE,
      maxNativeZoom: MAX_NATIVE,
      tms: false,
      noWrap: true
    });

    // Log utilissimo: se una tile manca vedrai l'URL preciso in console
    tiles.on('tileerror', e => console.warn('TILE 404:', e.tile.src));

    // Quando il layer si carica almeno una volta, centriamo e limitiamo la vista sui bounds reali dei tiles
    tiles.once('load', () => {
      const b = tiles.getBounds();
      if (b && b.isValid()) {
        map.fitBounds(b);
        map.setMaxBounds(b.pad(0.02));
        map.options.maxBoundsViscosity = 1.0;
      }
    });

    // Aggiungi i tiles personalizzati in mappa **sopra** OSM
    tiles.addTo(map);

    // 4) PUNTI (se esistono): evitiamo che un errore qui blocchi tutta la pagina
    try {
      if (typeof json_Insediamenti_1 !== 'undefined') {
        const punti = L.geoJson(json_Insediamenti_1, {
          onEachFeature: (f, layer) => {
            const p = f.properties || {};
            layer.bindPopup(
              `<table>
                <tr><th>Nome</th><td>${p.Nome ?? ''}</td></tr>
                <tr><th>Tipo</th><td>${p.Tipo ?? ''}</td></tr>
                <tr><th>Descrizione</th><td>${p.Descrizione ?? ''}</td></tr>
                <tr><th>Livello</th><td>${p.Livello ?? ''}</td></tr>
                <tr><th>Regione</th><td>${p.Regione ?? ''}</td></tr>
              </table>`
            );
          },
          pointToLayer: (_f, latlng) => L.circleMarker(latlng, {
            radius: 4, color: '#232323', weight: 1, fillColor: '#bed04f', fillOpacity: 1
          })
        }).addTo(map);

        // Se i punti hanno extent valido, usalo per centrare
        const bp = punti.getBounds();
        if (bp && bp.isValid()) map.fitBounds(bp);
      } else {
        console.info('Nota: data/Insediamenti_1.js non definisce json_Insediamenti_1 (punti non caricati).');
      }
    } catch (err) {
      console.warn('Impossibile caricare i punti (controlla data/Insediamenti_1.js):', err);
    }

    // 5) Controllo layer per passare tra OSM e Raster
    L.control.layers(
      { 'OSM (fallback)': osm, 'Raster': tiles },
      {},
      { collapsed: false }
    ).addTo(map);
  </script>
</body>
</html>
